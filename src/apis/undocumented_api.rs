/*
 * Galaxy API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 22.05.1
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`api_authenticate_baseauth_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiAuthenticateBaseauthGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_authz_encoded_authz_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudAuthzEncodedAuthzIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_authz_encoded_authz_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudAuthzEncodedAuthzIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_authz_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudAuthzGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_authz_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudAuthzPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_storage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudStorageGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_storage_get_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudStorageGetPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_cloud_storage_send_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCloudStorageSendPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_index_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversIndexGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_index_resolve_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversIndexResolveGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_index_resolve_install_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversIndexResolveInstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_index_toolbox_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversIndexToolboxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_index_toolbox_install_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversIndexToolboxInstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_resolve_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversResolveGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_resolve_install_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversResolveInstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_toolbox_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversToolboxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_container_resolvers_toolbox_install_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiContainerResolversToolboxInstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_datasets_dataset_id_metrics_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDatasetsDatasetIdMetricsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_datasets_dataset_id_parameters_display_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDatasetsDatasetIdParametersDisplayGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_clean_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversCleanPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_dependency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversDependencyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_dependency_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversDependencyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_index_clean_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversIndexCleanPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_index_dependency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversIndexDependencyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_index_dependency_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversIndexDependencyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_toolbox_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversToolboxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_toolbox_install_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversToolboxInstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_toolbox_uninstall_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversToolboxUninstallPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_unused_paths_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversUnusedPathsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dependency_resolvers_unused_paths_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDependencyResolversUnusedPathsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_display_applications_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDisplayApplicationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_display_applications_reload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDisplayApplicationsReloadPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dynamic_tools_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDynamicToolsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dynamic_tools_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDynamicToolsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dynamic_tools_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDynamicToolsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_dynamic_tools_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiDynamicToolsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_entry_points_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiEntryPointsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_folders_encoded_folder_id_contents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFoldersEncodedFolderIdContentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_folders_folder_id_contents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFoldersFolderIdContentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_folders_folder_id_contents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFoldersFolderIdContentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_forms_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFormsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_forms_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFormsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_forms_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiFormsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGroupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_groups_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGroupsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_groups_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGroupsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_groups_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGroupsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_annotation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdAnnotationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_annotation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdAnnotationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_annotation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdAnnotationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_annotation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_annotation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_annotation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_extended_metadata_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_extended_metadata_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_provenance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_provenance_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_provenance_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_provenance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdProvenancePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_tags_tag_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_tags_tag_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_tags_tag_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_contents_history_content_id_tags_tag_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_tags_tag_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdTagsTagNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_tags_tag_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdTagsTagNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_tags_tag_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdTagsTagNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_histories_history_id_tags_tag_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiHistoriesHistoryIdTagsTagNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_from_store_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsFromStorePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_biocompute_download_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdBiocomputeDownloadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_biocompute_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdBiocomputeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_report_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdReportGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_report_pdf_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdReportPdfGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_step_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdStepJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_steps_step_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdStepsStepIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_invocations_invocation_id_steps_step_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiInvocationsInvocationIdStepsStepIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_build_for_rerun_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdBuildForRerunGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_common_problems_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdCommonProblemsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_error_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdErrorPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_outputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdOutputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_id_resume_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsIdResumePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_destination_params_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdDestinationParamsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdFilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_files_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdFilesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_metrics_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdMetricsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_parameters_display_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdParametersDisplayGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_job_id_ports_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsJobIdPortsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_jobs_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiJobsSearchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_download_archive_format_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsDownloadArchiveFormatGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_download_archive_format_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsDownloadArchiveFormatPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_encoded_dataset_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsEncodedDatasetIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_encoded_dataset_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsEncodedDatasetIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_encoded_dataset_id_permissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsEncodedDatasetIdPermissionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_encoded_dataset_id_permissions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsEncodedDatasetIdPermissionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_encoded_dataset_id_versions_encoded_ldda_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsEncodedDatasetIdVersionsEncodedLddaIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_datasets_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesDatasetsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_library_content_id_extended_metadata_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_library_content_id_extended_metadata_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_libraries_library_id_contents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiLibrariesLibraryIdContentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_pages_page_id_revisions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiPagesPageIdRevisionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_pages_page_id_revisions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiPagesPageIdRevisionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_plugins_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiPluginsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_plugins_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiPluginsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_sanitize_allow_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSanitizeAllowDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_sanitize_allow_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSanitizeAllowGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_sanitize_allow_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSanitizeAllowPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiSearchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_check_for_updates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesCheckForUpdatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_new_install_repository_revision_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesNewInstallRepositoryRevisionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_reset_metadata_on_installed_repositories_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesResetMetadataOnInstalledRepositoriesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_repositories_reset_metadata_on_selected_installed_repositories_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRepositoriesResetMetadataOnSelectedInstalledRepositoriesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tool_shed_request_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolShedRequestGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_id_build_dependency_cache_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsIdBuildDependencyCachePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_id_dependencies_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsIdDependenciesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_id_dependencies_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsIdDependenciesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_id_install_dependencies_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsIdInstallDependenciesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_tools_tool_id_convert_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiToolsToolIdConvertPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trs_consume_servers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTrsConsumeServersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trs_consume_trs_server_tools_tool_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTrsConsumeTrsServerToolsToolIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trs_consume_trs_server_tools_tool_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTrsConsumeTrsServerToolsToolIdVersionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trs_consume_trs_server_tools_tool_id_versions_version_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTrsConsumeTrsServerToolsToolIdVersionsVersionIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_trs_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiTrsSearchGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_upload_hooks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUploadHooksPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_upload_resumable_upload_session_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUploadResumableUploadSessionIdPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_uploads_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUploadsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_uploads_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUploadsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_deleted_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersDeletedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_deleted_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersDeletedIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_deleted_id_undelete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersDeletedIdUndeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_api_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdApiKeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_api_key_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdApiKeyInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_api_key_inputs_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdApiKeyInputsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_api_key_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdApiKeyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_custom_builds_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdCustomBuildsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_custom_builds_key_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdCustomBuildsKeyDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_custom_builds_key_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdCustomBuildsKeyPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_favorites_object_type_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdFavoritesObjectTypeObjectIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_favorites_object_type_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdFavoritesObjectTypePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_information_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdInformationInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_information_inputs_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdInformationInputsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_password_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdPasswordInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_password_inputs_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdPasswordInputsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_permissions_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdPermissionsInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_permissions_inputs_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdPermissionsInputsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_toolbox_filters_inputs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdToolboxFiltersInputsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_id_toolbox_filters_inputs_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersIdToolboxFiltersInputsPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiUsersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_visualizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiVisualizationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_visualizations_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiVisualizationsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_visualizations_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiVisualizationsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_visualizations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiVisualizationsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_webhooks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWebhooksGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_webhooks_webhook_id_data_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWebhooksWebhookIdDataGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_download_workflow_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsDownloadWorkflowIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_get_tool_predictions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsGetToolPredictionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_id_refactor_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsIdRefactorPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsImportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_menu_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsMenuGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_menu_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsMenuPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsUploadPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_annotation_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdAnnotationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_annotation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdAnnotationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_annotation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdAnnotationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_download_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdDownloadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_biocompute_download_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeDownloadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_biocompute_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_report_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdReportGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_report_pdf_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdReportPdfGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_step_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdStepJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_steps_step_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_invocation_id_steps_step_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_invocations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdInvocationsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdTagsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_tags_tag_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdTagsTagNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_tags_tag_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdTagsTagNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_tags_tag_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdTagsTagNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_tags_tag_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdTagsTagNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_biocompute_download_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeDownloadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_biocompute_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_report_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdReportGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_report_pdf_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdReportPdfGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_step_jobs_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdStepJobsSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_steps_step_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_invocation_id_steps_step_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_usage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdUsagePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_workflows_workflow_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiWorkflowsWorkflowIdVersionsGetError {
    UnknownValue(serde_json::Value),
}


/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/authenticate/baseauth           returns an API key for authenticated user based on BaseAuth headers          :returns: api_key in json format         :rtype:   dict          :raises: ObjectNotFound, HTTPBadRequest         
pub async fn api_authenticate_baseauth_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiAuthenticateBaseauthGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/authenticate/baseauth/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiAuthenticateBaseauthGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * DELETE /api/cloud/authz/{encoded_authz_id}             Deletes the CloudAuthz record with the given ``encoded_authz_id`` from database.          :type  trans: galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans: Galaxy web transaction          :type  encoded_authz_id:    string         :param encoded_authz_id:    The encoded ID of the CloudAuthz record to be marked deleted.          :rtype  JSON         :return The cloudauthz record marked as deleted, serialized as a JSON object.         
pub async fn api_cloud_authz_encoded_authz_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudAuthzEncodedAuthzIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/authz/{encoded_authz_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudAuthzEncodedAuthzIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/cloud/authz/{encoded_authz_id}          Updates the values for the cloudauthz configuration with the given ``encoded_authz_id``.          With this API only the following attributes of a cloudauthz configuration         can be updated: `authn_id`, `provider`, `config`, `deleted`.          :type  trans:               galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans:               Galaxy web transaction          :type  encoded_authz_id:    string         :param encoded_authz_id:    The encoded ID of the CloudAuthz record to be updated.          :type payload:              dict         :param payload:             A dictionary structure containing the attributes to modified with their new values.                                     It can contain any number of the following attributes:                                          *   provider:   the cloud-based resource provider                                                         to which this configuration belongs to.                                          *   authn_id:   the (encoded) ID of a third-party authentication of a user.                                                         To have this ID, user must have logged-in to this Galaxy server                                                         using third-party identity (e.g., Google), or has associated                                                         their Galaxy account with a third-party OIDC-based identity.                                                         See this page: https://galaxyproject.org/authnz/config/                                                          Note: A user can associate a cloudauthz record with their own                                                         authentications only. If the given authentication with authn_id                                                         belongs to a different user, Galaxy will throw the                                                         ItemAccessibilityException exception.                                          *   config:     a dictionary containing all the configuration required to                                                         request temporary credentials from the provider.                                                         See the following page for details:                                                         https://galaxyproject.org/authnz/                                          *   deleted:    a boolean type marking the specified cloudauthz as (un)deleted.          
pub async fn api_cloud_authz_encoded_authz_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudAuthzEncodedAuthzIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/authz/{encoded_authz_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudAuthzEncodedAuthzIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/cloud/authz          Lists all the cloud authorizations user has defined.          :type  trans: galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans: Galaxy web transaction          :param kwargs: empty dict          :rtype: list of dict         :return: a list of cloud authorizations (each represented in key-value pair format) defined for the user.         
pub async fn api_cloud_authz_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudAuthzGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/authz/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudAuthzGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * POST /api/cloud/authz             Request to store the payload as a cloudauthz (cloud authorization) configuration for a user.          :type  trans: galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans: Galaxy web transaction          :type payload: dict         :param payload: A dictionary structure containing the following keys:             *   provider:       the cloud-based resource provider to which this configuration belongs to.              *   config:         a dictionary containing all the configuration required to request temporary credentials                                 from the provider. See the following page for details:                                 https://galaxyproject.org/authnz/              *   authn_id:       the (encoded) ID of a third-party authentication of a user. To have this ID, user must                                 have logged-in to this Galaxy server using third-party identity (e.g., Google), or has                                 associated his/her Galaxy account with a third-party OIDC-based identity. See this page:                                 https://galaxyproject.org/authnz/config/              *   description:    [Optional] a brief description for this configuration.          :param kwargs: empty dict          :rtype: dict         :return: a dictionary with the following kvp:             *   status:     HTTP response code             *   message:    A message complementary to the response code.         
pub async fn api_cloud_authz_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudAuthzPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/authz/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudAuthzPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/cloud/storage          Lists cloud-based buckets (e.g., S3 bucket, Azure blob) user has defined.          :return: A list of cloud-based buckets user has defined.         
pub async fn api_cloud_storage_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudStorageGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/storage/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudStorageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/cloud/storage/get          gets given objects from a given cloud-based bucket to a Galaxy history.          :type  trans: galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans: Galaxy web transaction          :type  payload: dict         :param payload: A dictionary structure containing the following keys:              *   history_id:    the (encoded) id of history to which the object should be received to.             *   bucket:        the name of a bucket from which data should be fetched from (e.g., a bucket name on AWS S3).             *   objects:       a list of the names of objects to be fetched.             *   authz_id:      the encoded ID of CloudAuthz to be used for authorizing access to the resource                                provider. You may get a list of the defined authorizations via                                `/api/cloud/authz`. Also, you can use `/api/cloud/authz/create` to define a                                new authorization.             *   input_args     [Optional; default value is an empty dict] a dictionary containing the following keys:                                  **   `dbkey`:           [Optional; default value: is `?`]                                                         Sets the genome (e.g., `hg19`) of the objects being                                                         fetched to Galaxy.                                  **   `file_type`:       [Optional; default value is `auto`]                                                         Sets the Galaxy datatype (e.g., `bam`) for the                                                         objects being fetched to Galaxy. See the following                                                         link for a complete list of Galaxy data types:                                                         https://galaxyproject.org/learn/datatypes/                                  **   `space_to_tab`:    [Optional; default value is `False`]                                                         A boolean value (\"true\" or \"false\") that sets if spaces                                                         should be converted to tab in the objects being                                                         fetched to Galaxy. Applicable only if `to_posix_lines`                                                         is True                                  **   `to_posix_lines`:  [Optional; default value is `Yes`]                                                         A boolean value (\"true\" or \"false\"); if \"Yes\", converts                                                         universal line endings to POSIX line endings. Set to                                                         \"False\" if you upload a gzip, bz2 or zip archive                                                         containing a binary file.          :param kwargs:          :rtype:  dictionary         :return: a dictionary containing a `summary` view of the datasets copied from the given cloud-based storage.          
pub async fn api_cloud_storage_get_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudStorageGetPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/storage/get", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudStorageGetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/cloud/storage/send          Sends given dataset(s) in a given history to a given cloud-based bucket. Each dataset is named         using the label assigned to the dataset in the given history (see `HistoryDatasetAssociation.name`).         If no dataset ID is given, this API sends all the datasets belonging to a given history to a given         cloud-based bucket.          :type  trans: galaxy.webapps.base.webapp.GalaxyWebTransaction         :param trans: Galaxy web transaction          :type  payload: dictionary         :param payload: A dictionary structure containing the following keys:              *   history_id              the (encoded) id of history from which the object should be downloaed.             *   bucket:                 the name of a bucket to which data should be sent (e.g., a bucket name on AWS S3).             *   authz_id:               the encoded ID of CloudAuthz to be used for authorizing access to the resource                                         provider. You may get a list of the defined authorizations via                                         `/api/cloud/authz`. Also, you can use `/api/cloud/authz/create` to define a                                         new authorization.             *   dataset_ids:            [Optional; default: None]                                         A list of encoded dataset IDs belonging to the specified history                                         that should be sent to the given bucket. If not provided, Galaxy sends                                         all the datasets belonging the specified history.             *   overwrite_existing:     [Optional; default: False]                                         A boolean value. If set to \"True\", and an object with same name of the dataset                                         to be sent already exist in the bucket, Galaxy replaces the existing object                                         with the dataset to be sent. If set to \"False\", Galaxy appends datetime                                         to the dataset name to prevent overwriting an existing object.          :rtype:     dictionary         :return:    Information about the (un)successfully submitted dataset send jobs,                     containing the following keys:                          *   `bucket_name`:                  The name of bucket to which the listed datasets are queued                                                             to be sent.                         *   `sent_dataset_labels`:          A list of JSON objects with the following key-value pair:                             **  `object`:                   The name of object is queued to be created.                             **  `job_id`:                   The id of the queued send job.                          *   `failed_dataset_labels`:        A list of JSON objects with the following key-value pair                                                             representing the datasets Galaxy failed to create                                                             (and queue) send job for:                              **  `object`:                   The name of object is queued to be created.                             **  `error`:                    A descriptive error message.          
pub async fn api_cloud_storage_send_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiCloudStorageSendPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/cloud/storage/send", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiCloudStorageSendPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers         
pub async fn api_container_resolvers_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers/<id>         
pub async fn api_container_resolvers_index_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversIndexGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/{index}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversIndexGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers/resolve         GET /api/container_resolvers/{index}/resolve          Resolve described requirement against specified container resolvers.          :type   tool_id:            str         :param  tool_id:            tool_id to resolve against containers         :type   requirements_only:  boolean         :param  requirements_only:  ignore tool containers, properties - just search based on tool requirements                                     set to True to mimic default behavior of tool dependency API.         :type   index:              int         :param  index:              index of the container resolver, if unset resolvers searched in order         :type   container_type:     str         :param  container_type:     restrict resolution to specified container type (e.g. 'docker', 'singularity')         :type   resolver_type:      str         :param  resolver_type:      restrict resolution to specified resolver type (e.g. 'build_mulled', 'explicit')         :type   install:            boolean         :param  install:            allow installation of new containers (for build_mulled* containers) the way job resolution                                     will operate, defaults to False         :rtype:     dict         :returns:   a dictified description of the container dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_container_resolvers_index_resolve_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversIndexResolveGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/{index}/resolve", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversIndexResolveGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/container_resolvers/resolve/install         POST /api/container_resolvers/{index}/resolve/install          Do the resolution of dependencies like resolve(), but allow building         and installing new containers during installation. payload of POST body maybe         contain same parameters as resolve query parameters.          :rtype:     dict         :returns:   a dictified description of the container dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_container_resolvers_index_resolve_install_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversIndexResolveInstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/{index}/resolve/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversIndexResolveInstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers/toolbox         GET /api/container_resolvers/{index}/toolbox          Apply resolve() to each tool in the toolbox and return the results as a list. See         documentation for resolve() for a description of parameters that can be consumed and         a description of the resulting items.          :type   tool_ids:            str         :param  tool_ids:            tool_ids to filter toolbox on          :rtype:     list         :returns:   list of items returned from resolve()         
pub async fn api_container_resolvers_index_toolbox_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversIndexToolboxGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/{index}/toolbox", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversIndexToolboxGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/container_resolvers/toolbox/install         POST /api/container_resolvers/{index}/toolbox/install          Do the resolution of dependencies like resolve_toolbox(), but allow building         and installing new containers. payload of POST body maybe contain same parameters         as resolve_toolbox query parameters.          :rtype:     list         :returns:   list of items returned from resolve()         
pub async fn api_container_resolvers_index_toolbox_install_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversIndexToolboxInstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/{index}/toolbox/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversIndexToolboxInstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers/resolve         GET /api/container_resolvers/{index}/resolve          Resolve described requirement against specified container resolvers.          :type   tool_id:            str         :param  tool_id:            tool_id to resolve against containers         :type   requirements_only:  boolean         :param  requirements_only:  ignore tool containers, properties - just search based on tool requirements                                     set to True to mimic default behavior of tool dependency API.         :type   index:              int         :param  index:              index of the container resolver, if unset resolvers searched in order         :type   container_type:     str         :param  container_type:     restrict resolution to specified container type (e.g. 'docker', 'singularity')         :type   resolver_type:      str         :param  resolver_type:      restrict resolution to specified resolver type (e.g. 'build_mulled', 'explicit')         :type   install:            boolean         :param  install:            allow installation of new containers (for build_mulled* containers) the way job resolution                                     will operate, defaults to False         :rtype:     dict         :returns:   a dictified description of the container dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_container_resolvers_resolve_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversResolveGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/resolve", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversResolveGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/container_resolvers/resolve/install         POST /api/container_resolvers/{index}/resolve/install          Do the resolution of dependencies like resolve(), but allow building         and installing new containers during installation. payload of POST body maybe         contain same parameters as resolve query parameters.          :rtype:     dict         :returns:   a dictified description of the container dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_container_resolvers_resolve_install_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversResolveInstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/resolve/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversResolveInstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/container_resolvers/toolbox         GET /api/container_resolvers/{index}/toolbox          Apply resolve() to each tool in the toolbox and return the results as a list. See         documentation for resolve() for a description of parameters that can be consumed and         a description of the resulting items.          :type   tool_ids:            str         :param  tool_ids:            tool_ids to filter toolbox on          :rtype:     list         :returns:   list of items returned from resolve()         
pub async fn api_container_resolvers_toolbox_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversToolboxGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/toolbox", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversToolboxGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/container_resolvers/toolbox/install         POST /api/container_resolvers/{index}/toolbox/install          Do the resolution of dependencies like resolve_toolbox(), but allow building         and installing new containers. payload of POST body maybe contain same parameters         as resolve_toolbox query parameters.          :rtype:     list         :returns:   list of items returned from resolve()         
pub async fn api_container_resolvers_toolbox_install_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiContainerResolversToolboxInstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/container_resolvers/toolbox/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiContainerResolversToolboxInstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{job_id}/metrics         * GET /api/datasets/{dataset_id}/metrics             Return job metrics for specified job. Job accessibility checks are slightly             different than dataset checks, so both methods are available.          :type   job_id: string         :param  job_id: Encoded job id          :type   dataset_id: string         :param  dataset_id: Encoded HDA or LDDA id          :type   hda_ldda: string         :param  hda_ldda: hda if dataset_id is an HDA id (default), ldda if                           it is an ldda id.          :rtype:     list         :returns:   list containing job metrics         
pub async fn api_datasets_dataset_id_metrics_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDatasetsDatasetIdMetricsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/datasets/{dataset_id}/metrics", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDatasetsDatasetIdMetricsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{job_id}/parameters_display         * GET /api/datasets/{dataset_id}/parameters_display              Resolve parameters as a list for nested display. More client logic             here than is ideal but it is hard to reason about tool parameter             types on the client relative to the server. Job accessibility checks             are slightly different than dataset checks, so both methods are             available.              This API endpoint is unstable and tied heavily to Galaxy's JS client code,             this endpoint will change frequently.          :type   job_id: string         :param  job_id: Encoded job id          :type   dataset_id: string         :param  dataset_id: Encoded HDA or LDDA id          :type   hda_ldda: string         :param  hda_ldda: hda if dataset_id is an HDA id (default), ldda if                           it is an ldda id.          :rtype:     list         :returns:   job parameters for for display         
pub async fn api_datasets_dataset_id_parameters_display_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDatasetsDatasetIdParametersDisplayGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/datasets/{dataset_id}/parameters_display", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDatasetsDatasetIdParametersDisplayGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/clean          Cleans up intermediate files created by resolvers during the dependency         installation.          :type   index:    int         :param  index:    index of the dependency resolver          :rtype:     dict         :returns:   a dictified description of the requirement that could                     be resolved (keyed on 'requirement') and the index of                     the corresponding resolver (keyed on 'index').         
pub async fn api_dependency_resolvers_clean_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversCleanPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/clean", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversCleanPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers/dependency          Resolve described requirement against all dependency resolvers, returning         the match with highest priority.          :type   index:    int         :param  index:    index of the dependency resolver         :type   kwds:     dict         :param  kwds:     dictionary structure containing extra parameters         :type   name:     str         :param  name:     name of the requirement to find a dependency for (required)         :type   version:  str         :param  version:  version of the requirement to find a dependency for (required)         :type   exact:    bool         :param  exact:    require an exact match to specify requirement (do not discard                           version information to resolve dependency).          :rtype:     dict         :returns:   a dictified description of the dependency, with type: None                     if no match was found.         
pub async fn api_dependency_resolvers_dependency_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversDependencyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/dependency", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversDependencyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/dependency         POST /api/dependency_resolvers/dependency          Install described requirement against specified dependency resolver.          :type   index:    int         :param  index:    index of the dependency resolver         :type   kwds:     dict         :param  kwds:     dictionary structure containing extra parameters         :type   name:     str         :param  name:     name of the requirement to find a dependency for (required)         :type   version:  str         :param  version:  version of the requirement to find a dependency for (required)         :type   exact:    bool         :param  exact:    require an exact match to specify requirement (do not discard                           version information to resolve dependency).         :type   tool_id:  str         :param  tool_id:  tool_id to install requirements for          :rtype:     dict         :returns:   a dictified description of the dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_dependency_resolvers_dependency_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversDependencyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/dependency", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversDependencyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers         
pub async fn api_dependency_resolvers_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers/<id>         
pub async fn api_dependency_resolvers_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/dependency_resolvers          Reload tool dependency resolution configuration.         
pub async fn api_dependency_resolvers_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/clean          Cleans up intermediate files created by resolvers during the dependency         installation.          :type   index:    int         :param  index:    index of the dependency resolver          :rtype:     dict         :returns:   a dictified description of the requirement that could                     be resolved (keyed on 'requirement') and the index of                     the corresponding resolver (keyed on 'index').         
pub async fn api_dependency_resolvers_index_clean_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversIndexCleanPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/{index}/clean", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversIndexCleanPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers/{index}/dependency          Resolve described requirement against specified dependency resolver.          :type   index:    int         :param  index:    index of the dependency resolver         :type   kwds:     dict         :param  kwds:     dictionary structure containing extra parameters         :type   name:     str         :param  name:     name of the requirement to find a dependency for (required)         :type   version:  str         :param  version:  version of the requirement to find a dependency for (required)         :type   exact:    bool         :param  exact:    require an exact match to specify requirement (do not discard                           version information to resolve dependency).          :rtype:     dict         :returns:   a dictified description of the dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_dependency_resolvers_index_dependency_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversIndexDependencyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/{index}/dependency", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversIndexDependencyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/dependency         POST /api/dependency_resolvers/dependency          Install described requirement against specified dependency resolver.          :type   index:    int         :param  index:    index of the dependency resolver         :type   kwds:     dict         :param  kwds:     dictionary structure containing extra parameters         :type   name:     str         :param  name:     name of the requirement to find a dependency for (required)         :type   version:  str         :param  version:  version of the requirement to find a dependency for (required)         :type   exact:    bool         :param  exact:    require an exact match to specify requirement (do not discard                           version information to resolve dependency).         :type   tool_id:  str         :param  tool_id:  tool_id to install requirements for          :rtype:     dict         :returns:   a dictified description of the dependency, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_dependency_resolvers_index_dependency_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversIndexDependencyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/{index}/dependency", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversIndexDependencyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers/toolbox          Summarize requirements across toolbox (for Tool Management grid). This is an experiemental         API particularly tied to the GUI - expect breaking changes until this notice is removed.          Container resolution via this API is especially experimental and the container resolution         API should be used to summarize this information instead in most cases.          :type   index:    int         :param  index:    index of the dependency resolver         :type   tool_ids: str         :param  tool_ids: tool_id to install dependency for         :type   resolver_type:  str         :param  resolver_type:  restrict to uninstall to specified resolver type         :type   include_containers: bool         :param  include_containers: include container resolvers in resolution         :type   container_type: str         :param  container_type: restrict to uninstall to specified container type         :type   index_by: str         :param  index_by: By default consider only context of requirements, group tools by requirements.                           Set this to 'tools' to summarize across all tools though. Tools may provide additional                           context for container resolution for instance.          :rtype:     list         :returns:   dictified descriptions of the dependencies, with attribute                     ``dependency_type: None`` if no match was found.         
pub async fn api_dependency_resolvers_toolbox_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversToolboxGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/toolbox", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversToolboxGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/toolbox/install         POST /api/dependency_resolvers/toolbox/install          Install described requirement against specified dependency resolver(s). This is an experiemental         API particularly tied to the GUI - expect breaking changes until this notice is removed.          :type   index:          int         :param  index:          index of the dependency resolver         :type   tool_ids:       str         :param  tool_ids:       tool_id to install dependency for         :type   resolver_type:  str         :param  resolver_type:  restrict to uninstall to specified resolver type         :type   include_containers: bool         :param  include_containers: include container resolvers in resolution         :type   container_type: str         :param  container_type: restrict to uninstall to specified container type         
pub async fn api_dependency_resolvers_toolbox_install_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversToolboxInstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/toolbox/install", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversToolboxInstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dependency_resolvers/{index}/toolbox/uninstall         POST /api/dependency_resolvers/toolbox/uninstall          Uninstall described requirement against specified dependency resolver(s). This is an experiemental         API particularly tied to the GUI - expect breaking changes until this notice is removed.          :type   index:          int         :param  index:          index of the dependency resolver         :type   tool_ids:       str         :param  tool_ids:       tool_id to install dependency for         :type   include_containers: bool         :param  include_containers: include container resolvers in resolution         :type   container_type: str         :param  container_type: restrict to uninstall to specified container type         :type   resolver_type:  str         :param  resolver_type:  restrict to uninstall to specified resolver type         
pub async fn api_dependency_resolvers_toolbox_uninstall_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversToolboxUninstallPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/toolbox/uninstall", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversToolboxUninstallPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dependency_resolvers/unused_paths         
pub async fn api_dependency_resolvers_unused_paths_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversUnusedPathsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/unused_paths", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversUnusedPathsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/dependency_resolvers/unused_paths         
pub async fn api_dependency_resolvers_unused_paths_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDependencyResolversUnusedPathsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dependency_resolvers/unused_paths", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDependencyResolversUnusedPathsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/display_applications/          Returns the list of display applications.          :returns:   list of available display applications         :rtype:     list         
pub async fn api_display_applications_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDisplayApplicationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/display_applications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDisplayApplicationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/display_applications/reload          Reloads the list of display applications.          :param  ids:  list containing ids of display to be reloaded         :type   ids:  list         
pub async fn api_display_applications_reload_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDisplayApplicationsReloadPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/display_applications/reload", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDisplayApplicationsReloadPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dynamic_tools          This returns meta-information about the dynamic tool, such as         tool_uuid. To use the tool or view funtional information such as         inputs and outputs, use the standard tools API indexed by the         ID (and optionally version) returned from this endpoint.         
pub async fn api_dynamic_tools_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDynamicToolsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dynamic_tools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDynamicToolsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/dynamic_tools/{encoded_dynamic_tool_id|tool_uuid}          Deactivate the specified dynamic tool. Deactivated tools will not         be loaded into the toolbox.         
pub async fn api_dynamic_tools_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDynamicToolsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dynamic_tools/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDynamicToolsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/dynamic_tools/{encoded_dynamic_tool_id|tool_uuid}         
pub async fn api_dynamic_tools_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDynamicToolsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dynamic_tools/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDynamicToolsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/dynamic_tools          The payload is expected to be a tool definition to dynamically load         into Galaxy's toolbox.          :type representation: dict         :param representation: a JSON-ified tool description to load         :type uuid: str         :param uuid: the uuid to associate with the tool being created         
pub async fn api_dynamic_tools_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiDynamicToolsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/dynamic_tools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiDynamicToolsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/entry_points/{id}         
pub async fn api_entry_points_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiEntryPointsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/entry_points/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiEntryPointsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/folders/{encoded_id}/contents          Create a new library file from an HDA.          :param  encoded_folder_id:      the encoded id of the folder to import dataset(s) to         :type   encoded_folder_id:      an encoded id string         :param  payload:    dictionary structure containing:             :param from_hda_id:         (optional) the id of an accessible HDA to copy into the library             :type  from_hda_id:         encoded id             :param from_hdca_id:         (optional) the id of an accessible HDCA to copy into the library             :type  from_hdca_id:         encoded id             :param ldda_message:        (optional) the new message attribute of the LDDA created             :type   ldda_message:       str             :param extended_metadata:   (optional) dub-dictionary containing any extended metadata to associate with the item             :type  extended_metadata:   dict         :type   payload:    dict          :returns:   a dictionary describing the new item if ``from_hda_id`` is supplied or a list of                     such dictionaries describing the new items if ``from_hdca_id`` is supplied.         :rtype:     object          :raises:    ObjectAttributeInvalidException,             InsufficientPermissionsException, ItemAccessibilityException,             InternalServerError         
pub async fn api_folders_encoded_folder_id_contents_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFoldersEncodedFolderIdContentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/folders/{encoded_folder_id}/contents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFoldersEncodedFolderIdContentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/folders/{encoded_folder_id}/contents?limit={limit}&offset={offset}          Displays a collection (list) of a folder's contents         (files and folders). Encoded folder ID is prepended         with 'F' if it is a folder as opposed to a data set         which does not have it. Full path is provided in         response as a separate object providing data for         breadcrumb path building.          ..example:             limit and offset can be combined. Skip the first two and return five:                 '?limit=3&offset=5'          :param  folder_id: encoded ID of the folder which             contents should be library_dataset_dict         :type   folder_id: encoded string          :param  offset: offset for returned library folder datasets         :type   folder_id: encoded string          :param  limit: limit   for returned library folder datasets             contents should be library_dataset_dict         :type   folder_id: encoded string          :param kwd: keyword dictionary with other params         :type  kwd: dict          :returns: dictionary containing all items and metadata         :type:    dict          :raises: MalformedId, InconsistentDatabase, ObjectNotFound,              InternalServerError         
pub async fn api_folders_folder_id_contents_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFoldersFolderIdContentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/folders/{folder_id}/contents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFoldersFolderIdContentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/folders/{encoded_id}/contents          Create a new library file from an HDA.          :param  encoded_folder_id:      the encoded id of the folder to import dataset(s) to         :type   encoded_folder_id:      an encoded id string         :param  payload:    dictionary structure containing:             :param from_hda_id:         (optional) the id of an accessible HDA to copy into the library             :type  from_hda_id:         encoded id             :param from_hdca_id:         (optional) the id of an accessible HDCA to copy into the library             :type  from_hdca_id:         encoded id             :param ldda_message:        (optional) the new message attribute of the LDDA created             :type   ldda_message:       str             :param extended_metadata:   (optional) dub-dictionary containing any extended metadata to associate with the item             :type  extended_metadata:   dict         :type   payload:    dict          :returns:   a dictionary describing the new item if ``from_hda_id`` is supplied or a list of                     such dictionaries describing the new items if ``from_hdca_id`` is supplied.         :rtype:     object          :raises:    ObjectAttributeInvalidException,             InsufficientPermissionsException, ItemAccessibilityException,             InternalServerError         
pub async fn api_folders_folder_id_contents_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFoldersFolderIdContentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/folders/{folder_id}/contents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFoldersFolderIdContentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/forms         Displays a collection (list) of forms.         
pub async fn api_forms_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFormsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/forms", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFormsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/forms/{encoded_form_id}         Displays information about a form.         
pub async fn api_forms_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFormsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/forms/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFormsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/forms         Creates a new form.         
pub async fn api_forms_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiFormsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/forms", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiFormsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/groups         Displays a collection (list) of groups.         
pub async fn api_groups_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiGroupsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiGroupsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/groups/{encoded_group_id}         Displays information about a group.         
pub async fn api_groups_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiGroupsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/groups/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiGroupsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/groups/{encoded_group_id}         Modifies a group.         
pub async fn api_groups_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiGroupsIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/groups/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiGroupsIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/groups         Creates a new group.         
pub async fn api_groups_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiGroupsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiGroupsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_annotation_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdAnnotationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdAnnotationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_annotation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdAnnotationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/annotation/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdAnnotationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_annotation_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdAnnotationPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdAnnotationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_annotation_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_annotation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/annotation/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_annotation_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdAnnotationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_extended_metadata_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/extended_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_extended_metadata_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/extended_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdExtendedMetadataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_provenance_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/provenance", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_provenance_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/provenance/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_provenance_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/provenance/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdProvenanceIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_histories_history_id_contents_history_content_id_provenance_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdProvenancePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/provenance", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdProvenancePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_contents_history_content_id_tags_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_contents_history_content_id_tags_tag_name_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_contents_history_content_id_tags_tag_name_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNameGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_contents_history_content_id_tags_tag_name_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_contents_history_content_id_tags_tag_name_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/contents/{history_content_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdContentsHistoryContentIdTagsTagNamePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_tags_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_tags_tag_name_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdTagsTagNameDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdTagsTagNameDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_tags_tag_name_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdTagsTagNameGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdTagsTagNameGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_tags_tag_name_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdTagsTagNamePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdTagsTagNamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_histories_history_id_tags_tag_name_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiHistoriesHistoryIdTagsTagNamePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/histories/{history_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiHistoriesHistoryIdTagsTagNamePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/invocations/from_store          Create invocation(s) from a supplied model store.          Input can be an archive describing a Galaxy model store containing an         workflow invocation - for instance one created with with write_store         or prepare_store_download endpoint.         
pub async fn api_invocations_from_store_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsFromStorePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/from_store", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsFromStorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations         GET /api/invocations          Get the list of a user's workflow invocations. If workflow_id is supplied         (either via URL or query parameter) it should be an encoded StoredWorkflow id         and returned invocations will be restricted to that workflow. history_id (an encoded         History id) can be used to further restrict the query. If neither a workflow_id or         history_id is supplied, all the current user's workflow invocations will be indexed         (as determined by the invocation being executed on one of the user's histories).          :param  workflow_id:      an encoded stored workflow id to restrict query to         :type   workflow_id:      str          :param  instance:         true if fetch by Workflow ID instead of StoredWorkflow id, false                                   by default.         :type   instance:         boolean          :param  history_id:       an encoded history id to restrict query to         :type   history_id:       str          :param  job_id:           an encoded job id to restrict query to         :type   job_id:           str          :param  user_id:          an encoded user id to restrict query to, must be own id if not admin user         :type   user_id:          str          :param  view:             level of detail to return per invocation 'element' or 'collection'.         :type   view:             str          :param  step_details:     If 'view' is 'element', also include details on individual steps.         :type   step_details:     bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_invocations_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute/download          Returns a selected BioCompute Object as a file for download (HTTP         headers configured with filename and such).          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_invocations_invocation_id_biocompute_download_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdBiocomputeDownloadGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/biocompute/download", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdBiocomputeDownloadGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute          Return a BioCompute Object for the workflow invocation.          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_invocations_invocation_id_biocompute_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdBiocomputeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/biocompute", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdBiocomputeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/workflows/{workflow_id}/invocations/{invocation_id}         DELETE /api/invocations/{invocation_id}         Cancel the specified workflow invocation.          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_invocations_invocation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}         GET /api/invocations/{invocation_id}          Get detailed description of workflow invocation          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_details:       fetch details about individual invocation steps                                     and populate a steps attribute in the resulting                                     dictionary. Defaults to false.         :type   step_details:       bool          :param  legacy_job_state:   If step_details is true, and this is set to true                                     populate the invocation step state with the job state                                     instead of the invocation step state. This will also                                     produce one step per job in mapping jobs to mimic the                                     older behavior with respect to collections. Partially                                     scheduled steps may provide incomplete information                                     and the listed steps outputs are the mapped over                                     step outputs but the individual job outputs                                     when this is set - at least for now.         :type   legacy_job_state:   bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_invocations_invocation_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/jobs_summary         GET /api/invocations/{invocation_id}/jobs_summary          return job state summary info aggregated across all current jobs of workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict         :returns:   a job summary object merged for all steps in workflow invocation         
pub async fn api_invocations_invocation_id_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report         GET /api/invocations/{invocation_id}/report          Get JSON summarizing invocation for reporting.         
pub async fn api_invocations_invocation_id_report_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdReportGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/report", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdReportGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report.pdf         GET /api/invocations/{invocation_id}/report.pdf          Get JSON summarizing invocation for reporting.         
pub async fn api_invocations_invocation_id_report_pdf_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdReportPdfGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/report.pdf", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdReportPdfGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/step_jobs_summary         GET /api/invocations/{invocation_id}/step_jobs_summary          return job state summary info aggregated across per step of the workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict[]         :returns:   an array of job summary object dictionaries for each step         
pub async fn api_invocations_invocation_id_step_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdStepJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/step_jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdStepJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         GET /api/invocations/{invocation_id}/steps/{step_id}          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :param  payload:       payload containing update action information                                for running workflow.          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_invocations_invocation_id_steps_step_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdStepsStepIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdStepsStepIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         PUT /api/invocations/{invocation_id}/steps/{step_id}          Update state of running workflow step invocation - still very nebulous         but this would be for stuff like confirming paused steps can proceed         etc....          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_invocations_invocation_id_steps_step_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiInvocationsInvocationIdStepsStepIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/invocations/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiInvocationsInvocationIdStepsStepIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{id}/build_for_rerun             returns a tool input/param template prepopulated with this job's             information, suitable for rerunning or rendering parameters of the             job.          :type   id: string         :param  id: Encoded job id          :rtype:     dictionary         :returns:   dictionary containing output dataset associations         
pub async fn api_jobs_id_build_for_rerun_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdBuildForRerunGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/build_for_rerun", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdBuildForRerunGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{id}/common_problems             check inputs and job for common potential problems to aid in error reporting         
pub async fn api_jobs_id_common_problems_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdCommonProblemsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/common_problems", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdCommonProblemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          error( trans, id )         * POST /api/jobs/{id}/error             submits a bug report via the API.          :type   id: string         :param  id: Encoded job id          :rtype:     dictionary         :returns:   dictionary containing information regarding where the error report was sent.         
pub async fn api_jobs_id_error_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdErrorPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/error", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdErrorPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/jobs/{id}/inputs          returns input datasets created by job          :type   id: string         :param  id: Encoded job id          :rtype:     dictionary         :returns:   dictionary containing input dataset associations         
pub async fn api_jobs_id_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          outputs( trans, id )         * GET /api/jobs/{id}/outputs             returns output datasets created by job          :type   id: string         :param  id: Encoded job id          :rtype:     dictionary         :returns:   dictionary containing output dataset associations         
pub async fn api_jobs_id_outputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdOutputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/outputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdOutputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * PUT /api/jobs/{id}/resume             Resumes a paused job          :type   id: string         :param  id: Encoded job id          :rtype:     dictionary         :returns:   dictionary containing output dataset associations         
pub async fn api_jobs_id_resume_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsIdResumePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{id}/resume", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsIdResumePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{job_id}/destination_params             Return destination parameters for specified job.          :type   job_id: string         :param  job_id: Encoded job id          :rtype:     list         :returns:   list containing job destination parameters         
pub async fn api_jobs_job_id_destination_params_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdDestinationParamsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/destination_params", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdDestinationParamsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/jobs/{job_id}/files          Get a file required to staging a job (proper datasets, extra inputs,         task-split inputs, working directory files).          :type   job_id: str         :param  job_id: encoded id string of the job         :type   path: str         :param  path: Path to file.         :type   job_key: str         :param  job_key: A key used to authenticate this request as acting on                          behalf or a job runner for the specified job.          ..note:             This API method is intended only for consumption by job runners,             not end users.          :rtype:     binary         :returns:   contents of file         
pub async fn api_jobs_job_id_files_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdFilesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/files", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdFilesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          create( self, trans, job_id, payload, **kwargs )         * POST /api/jobs/{job_id}/files             Populate an output file (formal dataset, task split part, working             directory file (such as those related to metadata)). This should be             a multipart post with a 'file' parameter containing the contents of             the actual file to create.          :type   job_id: str         :param  job_id: encoded id string of the job         :type   payload:    dict         :param  payload:    dictionary structure containing::             'job_key'   = Key authenticating             'path'      = Path to file to create.          ..note:             This API method is intended only for consumption by job runners,             not end users.          :rtype:     dict         :returns:   an okay message         
pub async fn api_jobs_job_id_files_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdFilesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/files", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdFilesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{job_id}/metrics         * GET /api/datasets/{dataset_id}/metrics             Return job metrics for specified job. Job accessibility checks are slightly             different than dataset checks, so both methods are available.          :type   job_id: string         :param  job_id: Encoded job id          :type   dataset_id: string         :param  dataset_id: Encoded HDA or LDDA id          :type   hda_ldda: string         :param  hda_ldda: hda if dataset_id is an HDA id (default), ldda if                           it is an ldda id.          :rtype:     list         :returns:   list containing job metrics         
pub async fn api_jobs_job_id_metrics_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdMetricsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/metrics", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdMetricsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * GET /api/jobs/{job_id}/parameters_display         * GET /api/datasets/{dataset_id}/parameters_display              Resolve parameters as a list for nested display. More client logic             here than is ideal but it is hard to reason about tool parameter             types on the client relative to the server. Job accessibility checks             are slightly different than dataset checks, so both methods are             available.              This API endpoint is unstable and tied heavily to Galaxy's JS client code,             this endpoint will change frequently.          :type   job_id: string         :param  job_id: Encoded job id          :type   dataset_id: string         :param  dataset_id: Encoded HDA or LDDA id          :type   hda_ldda: string         :param  hda_ldda: hda if dataset_id is an HDA id (default), ldda if                           it is an ldda id.          :rtype:     list         :returns:   job parameters for for display         
pub async fn api_jobs_job_id_parameters_display_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdParametersDisplayGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/parameters_display", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdParametersDisplayGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          create( self, trans, job_id, payload, **kwargs )         * POST /api/jobs/{job_id}/ports             Populate port information for interactive tools.          :type   job_id: str         :param  job_id: encoded id string of the job         :type   payload:    dict         :param  payload:    dictionary structure containing::             'job_key'           = Key authenticating             'container_runtime' = Path to file to create.          ..note:             This API method is intended only for consumption by job runners,             not end users.          :rtype:     dict         :returns:   an okay message         
pub async fn api_jobs_job_id_ports_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsJobIdPortsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/{job_id}/ports", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsJobIdPortsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          search( trans, payload )         * POST /api/jobs/search:             return jobs for current user          :type   payload: dict         :param  payload: Dictionary containing description of requested job. This is in the same format as             a request to POST /apt/tools would take to initiate a job          :rtype:     list         :returns:   list of dictionaries containing summary job information of the jobs that match the requested job run          This method is designed to scan the list of previously run jobs and find records of jobs that had         the exact some input parameters and datasets. This can be used to minimize the amount of repeated work, and simply         recycle the old results.         
pub async fn api_jobs_search_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiJobsSearchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/jobs/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiJobsSearchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/datasets/download/{archive_format}         POST /api/libraries/datasets/download/{archive_format}          Download requested datasets (identified by encoded IDs) in requested archive_format.          example: ``GET localhost:8080/api/libraries/datasets/download/tbz?ld_ids%255B%255D=a0d84b45643a2678&ld_ids%255B%255D=fe38c84dcd46c828``          .. note:: supported archive_format values are: 'zip', 'tgz', 'tbz', 'uncompressed'          :param  archive_format:      string representing requested archive archive_format         :type   archive_format:      string         :param  ld_ids[]:      an array of encoded dataset ids         :type   ld_ids[]:      an array         :param  folder_ids[]:      an array of encoded folder ids         :type   folder_ids[]:      an array          :returns: either archive with the requested datasets packed inside or a single uncompressed dataset         :rtype:   file          :raises: MessageException, ItemDeletionException, ItemAccessibilityException, HTTPBadRequest, OSError, IOError, ObjectNotFound         
pub async fn api_libraries_datasets_download_archive_format_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsDownloadArchiveFormatGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/download/{archive_format}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsDownloadArchiveFormatGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/datasets/download/{archive_format}         POST /api/libraries/datasets/download/{archive_format}          Download requested datasets (identified by encoded IDs) in requested archive_format.          example: ``GET localhost:8080/api/libraries/datasets/download/tbz?ld_ids%255B%255D=a0d84b45643a2678&ld_ids%255B%255D=fe38c84dcd46c828``          .. note:: supported archive_format values are: 'zip', 'tgz', 'tbz', 'uncompressed'          :param  archive_format:      string representing requested archive archive_format         :type   archive_format:      string         :param  ld_ids[]:      an array of encoded dataset ids         :type   ld_ids[]:      an array         :param  folder_ids[]:      an array of encoded folder ids         :type   folder_ids[]:      an array          :returns: either archive with the requested datasets packed inside or a single uncompressed dataset         :rtype:   file          :raises: MessageException, ItemDeletionException, ItemAccessibilityException, HTTPBadRequest, OSError, IOError, ObjectNotFound         
pub async fn api_libraries_datasets_download_archive_format_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsDownloadArchiveFormatPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/download/{archive_format}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsDownloadArchiveFormatPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/libraries/datasets/{encoded_dataset_id}          Mark the dataset deleted or undeleted.          :param  encoded_dataset_id:      the encoded id of the dataset to change         :type   encoded_dataset_id:      an encoded id string         :param  undelete:                flag whether to undeleted instead of deleting         :type   undelete:                bool          :returns:   dict containing information about the dataset         :rtype:     dictionary         
pub async fn api_libraries_datasets_encoded_dataset_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsEncodedDatasetIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{encoded_dataset_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsEncodedDatasetIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PATCH /api/libraries/datasets/{encoded_dataset_id}          Update the given library dataset (the latest linked ldda).          :param  encoded_dataset_id: the encoded id of the library dataset to update         :type   encoded_dataset_id: an encoded id string         :param  payload:            dictionary structure containing::             :param name:            new ld's name, must be longer than 0             :type  name:            str             :param misc_info:       new ld's misc info             :type  misc_info:       str             :param file_ext:        new ld's extension, must exist in the Galaxy registry             :type  file_ext:        str             :param genome_build:    new ld's genome build             :type  genome_build:    str             :param tags:            list of dataset tags             :type  tags:            list         :type   payload: dict          :returns:   detailed library dataset information         :rtype:     dictionary         
pub async fn api_libraries_datasets_encoded_dataset_id_patch(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsEncodedDatasetIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{encoded_dataset_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsEncodedDatasetIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/datasets/{encoded_dataset_id}/permissions          Display information about current or available roles for a given dataset permission.          :param  encoded_dataset_id:      the encoded id of the dataset to query         :type   encoded_dataset_id:      an encoded id string          :param  scope:      either 'current' or 'available'         :type   scope:      string          :returns:   either dict of current roles for all permission types                     or dict of available roles to choose from (is the same for any permission type)         :rtype:     dictionary          :raises: InsufficientPermissionsException         
pub async fn api_libraries_datasets_encoded_dataset_id_permissions_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsEncodedDatasetIdPermissionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{encoded_dataset_id}/permissions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsEncodedDatasetIdPermissionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/libraries/datasets/{encoded_dataset_id}/permissions          Set permissions of the given library dataset to the given role ids.          :param  encoded_dataset_id:      the encoded id of the dataset to update permissions of         :type   encoded_dataset_id:      an encoded id string         :param   payload: dictionary structure containing:              :param  action:     (required) describes what action should be performed                                 available actions: make_private, remove_restrictions, set_permissions             :type   action:     string             :param  access_ids[]:      list of Role.id defining roles that should have access permission on the dataset             :type   access_ids[]:      string or list             :param  manage_ids[]:      list of Role.id defining roles that should have manage permission on the dataset             :type   manage_ids[]:      string or list             :param  modify_ids[]:      list of Role.id defining roles that should have modify permission on the library dataset item             :type   modify_ids[]:      string or list          :type:      dictionary          :returns:   dict of current roles for all available permission types         :rtype:     dictionary          :raises: RequestParameterInvalidException, ObjectNotFound, InsufficientPermissionsException, InternalServerError                     RequestParameterMissingException         
pub async fn api_libraries_datasets_encoded_dataset_id_permissions_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsEncodedDatasetIdPermissionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{encoded_dataset_id}/permissions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsEncodedDatasetIdPermissionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/datasets/{encoded_dataset_id}/versions/{encoded_ldda_id}          Display a specific version of a library dataset (i.e. ldda).          :param  encoded_dataset_id:      the encoded id of the related library dataset         :type   encoded_dataset_id:      an encoded id string          :param  encoded_ldda_id:      the encoded id of the ldda to query         :type   encoded_ldda_id:      an encoded id string          :returns:   dict of ldda's details         :rtype:     dictionary          :raises: ObjectNotFound         
pub async fn api_libraries_datasets_encoded_dataset_id_versions_encoded_ldda_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsEncodedDatasetIdVersionsEncodedLddaIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{encoded_dataset_id}/versions/{encoded_ldda_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsEncodedDatasetIdVersionsEncodedLddaIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/datasets/{encoded_dataset_id}          Show the details of a library dataset.          :param  id:      the encoded id of the library dataset to query         :type   id:      an encoded id string          :returns:   detailed library dataset information         :rtype:     dictionary         
pub async fn api_libraries_datasets_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/libraries/datasets          Load dataset(s) from the given source into the library.          :param   payload: dictionary structure containing:             :param  encoded_folder_id:      the encoded id of the folder to import dataset(s) to             :type   encoded_folder_id:      an encoded id string             :param  source:                  source the datasets should be loaded from. Source can be:                      - user directory                          root folder specified in galaxy.ini as \"$user_library_import_dir\"                         example path: path/to/galaxy/$user_library_import_dir/user@example.com/{user can browse everything here}                         the folder with the user login has to be created beforehand                      - (admin)import directory                          root folder specified in galaxy ini as \"$library_import_dir\"                         example path: path/to/galaxy/$library_import_dir/{admin can browse everything here}                      - (admin)any absolute or relative path                          option allowed with \"allow_library_path_paste\" in galaxy.ini              :type   source:                 str             :param  link_data:                  flag whether to link the dataset to data or copy it to Galaxy, defaults to copy                 while linking is set to True all symlinks will be resolved _once_              :type   link_data:              bool             :param  preserve_dirs:                  flag whether to preserve the directory structure when importing dir                 if False only datasets will be imported              :type   preserve_dirs:          bool             :param  file_type:              file type of the loaded datasets, defaults to 'auto' (autodetect)             :type   file_type:              str             :param  dbkey:                  dbkey of the loaded genome, defaults to '?' (unknown)             :type   dbkey:                  str             :param  tag_using_filenames:    flag whether to generate dataset tags from filenames             :type   tag_using_filenames:    bool          :type   dictionary          :returns:   dict containing information about the created upload job         :rtype:     dictionary          :raises: RequestParameterMissingException, AdminRequiredException, ConfigDoesNotAllowException, RequestParameterInvalidException                     InsufficientPermissionsException, ObjectNotFound         
pub async fn api_libraries_datasets_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesDatasetsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/datasets/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesDatasetsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/{library_id}/contents:          Return a list of library files and folders.          .. note:: This endpoint is slow for large libraries. Returns all content traversing recursively through all folders.         .. seealso:: :class:`galaxy.webapps.galaxy.api.FolderContentsController.index` for a faster non-recursive solution          :param  library_id: the encoded id of the library         :type   library_id: str          :returns:   list of dictionaries of the form:              * id:   the encoded id of the library item             * name: the 'library path'                 or relationship of the library item to the root             * type: 'file' or 'folder'             * url:  the url to get detailed information on the library item          :rtype:     list          :raises:  MalformedId, InconsistentDatabase, RequestParameterInvalidException, InternalServerError         
pub async fn api_libraries_library_id_contents_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/libraries/{library_id}/contents/{id}          Delete the LibraryDataset with the given ``id``.          :type   id:     str         :param  id:     the encoded id of the library dataset to delete         :type   kwd:    dict         :param  kwd:    (optional) dictionary structure containing:              * payload:     a dictionary itself containing:                 * purge:   if True, purge the LD          :rtype:     dict         :returns:   an error object if an error occurred or a dictionary containing:             * id:         the encoded id of the library dataset,             * deleted:    if the library dataset was marked as deleted,             * purged:     if the library dataset was purged         
pub async fn api_libraries_library_id_contents_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/libraries/{library_id}/contents/{id}          Returns information about library file or folder.          :param  id:         the encoded id of the library item to return         :type   id:         str          :param  library_id: the encoded id of the library that contains this item         :type   library_id: str          :returns:   detailed library item information         :rtype:     dict          .. seealso::             :func:`galaxy.model.LibraryDataset.to_dict` and             :attr:`galaxy.model.LibraryFolder.dict_element_visible_keys`         
pub async fn api_libraries_library_id_contents_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/libraries/{library_id}/contents/{id}          Create an ImplicitlyConvertedDatasetAssociation.          .. seealso:: :class:`galaxy.model.ImplicitlyConvertedDatasetAssociation`          :type   id:         str         :param  id:         the encoded id of the library item to return         :type   library_id: str         :param  library_id: the encoded id of the library that contains this item         :type   payload:    dict         :param  payload:    dictionary structure containing::             'converted_dataset_id':          :rtype:     None         :returns:   None         
pub async fn api_libraries_library_id_contents_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_libraries_library_id_contents_library_content_id_extended_metadata_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents/{library_content_id}/extended_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_libraries_library_id_contents_library_content_id_extended_metadata_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents/{library_content_id}/extended_metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsLibraryContentIdExtendedMetadataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/libraries/{library_id}/contents:          Create a new library file or folder.          To copy an HDA into a library send ``create_type`` of 'file' and         the HDA's encoded id in ``from_hda_id`` (and optionally ``ldda_message``).          To copy an HDCA into a library send ``create_type`` of 'file' and         the HDCA's encoded id in ``from_hdca_id`` (and optionally ``ldda_message``).          :type   library_id: str         :param  library_id: the encoded id of the library where to create the new item         :type   payload:    dict         :param  payload:    dictionary structure containing:              * folder_id:    the encoded id of the parent folder of the new item             * create_type:  the type of item to create ('file', 'folder' or 'collection')             * from_hda_id:  (optional, only if create_type is 'file') the                 encoded id of an accessible HDA to copy into the library             * ldda_message: (optional) the new message attribute of the LDDA created             * extended_metadata: (optional) sub-dictionary containing any extended                 metadata to associate with the item             * upload_option: (optional) one of 'upload_file' (default), 'upload_directory' or 'upload_paths'             * server_dir: (optional, only if upload_option is                 'upload_directory') relative path of the subdirectory of Galaxy                 ``library_import_dir`` (if admin) or ``user_library_import_dir``                 (if non-admin) to upload. All and only the files (i.e.                 no subdirectories) contained in the specified directory will be                 uploaded.             * filesystem_paths: (optional, only if upload_option is                 'upload_paths' and the user is an admin) file paths on the                 Galaxy server to upload to the library, one file per line             * link_data_only: (optional, only when upload_option is                 'upload_directory' or 'upload_paths') either 'copy_files'                 (default) or 'link_to_files'. Setting to 'link_to_files'                 symlinks instead of copying the files             * name: (optional, only if create_type is 'folder') name of the                 folder to create             * description: (optional, only if create_type is 'folder')                 description of the folder to create             * tag_using_filenames: (optional)                 create tags on datasets using the file's original name             * tags: (optional)                 create the given list of tags on datasets          :returns:   a dictionary describing the new item unless ``from_hdca_id`` is supplied,                     in that case a list of such dictionaries is returned.         :rtype:     object         
pub async fn api_libraries_library_id_contents_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiLibrariesLibraryIdContentsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/libraries/{library_id}/contents", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiLibrariesLibraryIdContentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          index( self, trans, page_id, **kwd )         * GET /api/pages/{page_id}/revisions             return a list of Page revisions          :param page_id: Display the revisions of Page with ID=page_id          :rtype:     list         :returns:   dictionaries containing different revisions of the page         
pub async fn api_pages_page_id_revisions_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiPagesPageIdRevisionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/pages/{page_id}/revisions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiPagesPageIdRevisionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          create( self, trans, page_id, payload **kwd )         * POST /api/pages/{page_id}/revisions             Create a new revision for a page          :param page_id: Add revision to Page with ID=page_id         :param payload: A dictionary containing::             'content'   = New content of new page revision          :rtype:     dictionary         :returns:   Dictionary with 'success' or 'error' element to indicate the result of the request         
pub async fn api_pages_page_id_revisions_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiPagesPageIdRevisionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/pages/{page_id}/revisions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiPagesPageIdRevisionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/plugins:         
pub async fn api_plugins_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiPluginsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/plugins", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiPluginsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/plugins/{id}:         
pub async fn api_plugins_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiPluginsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/plugins/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiPluginsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/sanitize_allow         Remove tool_id from allowlist.         
pub async fn api_sanitize_allow_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiSanitizeAllowDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/sanitize_allow", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiSanitizeAllowDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/sanitize_allow         Return an object showing the current state of the toolbox and allow list.         
pub async fn api_sanitize_allow_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiSanitizeAllowGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/sanitize_allow", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiSanitizeAllowGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/sanitize_allow         Add a new tool_id to the allowlist.         
pub async fn api_sanitize_allow_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiSanitizeAllowPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/sanitize_allow", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiSanitizeAllowPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/search         Do a search of the various elements of Galaxy.         
pub async fn api_search_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiSearchPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiSearchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tool_shed         Interact with the Toolshed registry of this instance.         
pub async fn api_tool_shed_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tool_shed_repositories/check_for_updates         Check for updates to the specified repository, or all installed repositories.          :param id: the encoded repository id         
pub async fn api_tool_shed_repositories_check_for_updates_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesCheckForUpdatesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/check_for_updates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesCheckForUpdatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/tool_shed_repositories/id         DELETE /api/tool_shed_repositories/          :param id:  encoded repository id. Either id or name, owner, changeset_revision and tool_shed_url need to be supplied         :param kwd:              'remove_from_disk': Remove repository from disk or deactivate repository. Defaults to `True` (= remove repository from disk).             'name': Repository name             'owner': Repository owner             'changeset_revision': Changeset revision to uninstall             'tool_shed_url': Tool Shed URL          
pub async fn api_tool_shed_repositories_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tool_shed_repositories         Display a list of dictionaries containing information about installed tool shed repositories.         
pub async fn api_tool_shed_repositories_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/tool_shed_repositories/id         DELETE /api/tool_shed_repositories/          :param id:  encoded repository id. Either id or name, owner, changeset_revision and tool_shed_url need to be supplied         :param kwd:              'remove_from_disk': Remove repository from disk or deactivate repository. Defaults to `True` (= remove repository from disk).             'name': Repository name             'owner': Repository owner             'changeset_revision': Changeset revision to uninstall             'tool_shed_url': Tool Shed URL          
pub async fn api_tool_shed_repositories_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tool_shed_repositories/{encoded_tool_shed_repsository_id}          Display a dictionary containing information about a specified tool_shed_repository.          .. code-block::              {                 id: (string) Galaxy ID                 status: (string) Installation status                 name: (string) Repository name                 deleted: (bool) Repository deleted                 ctx_rev: (int) Changeset revision number (0, 1, 2...)                 error_message: (string) Installation error message                 installed_changeset_revision: (string) Initially installed changeset revision. Used to construct path to repository within Galaxies filesystem. Does not change if a repository is updated.                 tool_shed: (string) Repository toolshed hostname                 dist_to_shed: (bool)                 url: (string) API url of repository                 uninstalled: (bool) Tool has been uninstalled                 owner: (string) Repository owner within toolshed                 changeset_revision: (string) Changeset revision of repository                 include_datatypes: (bool) Repository includes installed datatypes                 tool_shed_status: (dict) See https://github.com/galaxyproject/galaxy/issues/10453                     latest_installable_revision: (string) Most recent version available on toolshed                     revision_update: (string)                     revision_upgrade: (string)                     repository_deprecated: (string) Repository has been depreciated             }          :param id: the encoded id of the ToolShedRepository object         
pub async fn api_tool_shed_repositories_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tool_shed_repositories/install_repository_revision         Install a specified repository revision from a specified tool shed into Galaxy.          :param key: the current Galaxy admin user's API key          The following parameters are included in the payload.         :param tool_shed_url (required): the base URL of the Tool Shed from which to install the Repository         :param name (required): the name of the Repository         :param owner (required): the owner of the Repository         :param changeset_revision (required): the changeset_revision of the RepositoryMetadata object associated with the Repository         :param new_tool_panel_section_label (optional):              label of a new section to be added to the Galaxy tool panel in which to load             tools contained in the Repository.  Either this parameter must be an empty string or             the tool_panel_section_id parameter must be an empty string or both must be an empty             string (both cannot be used simultaneously).          :param tool_panel_section_id (optional):              id of the Galaxy tool panel section in which to load tools contained in the Repository.             If this parameter is an empty string and the above new_tool_panel_section_label parameter is an             empty string, tools will be loaded outside of any sections in the tool panel.  Either this             parameter must be an empty string or the tool_panel_section_id parameter must be an empty string             of both must be an empty string (both cannot be used simultaneously).          :param install_repository_dependencies (optional):              Set to True if you want to install repository dependencies defined for the specified             repository being installed.  The default setting is False.          :param install_tool_dependencies (optional):              Set to True if you want to install tool dependencies defined for the specified repository being             installed.  The default setting is False.          :param shed_tool_conf (optional):              The shed-related tool panel configuration file configured in the \"tool_config_file\" setting in the Galaxy config file             (e.g., galaxy.ini).  At least one shed-related tool panel config file is required to be configured. Setting             this parameter to a specific file enables you to choose where the specified repository will be installed because             the tool_path attribute of the <toolbox> from the specified file is used as the installation location             (e.g., <toolbox tool_path=\"database/shed_tools\">).  If this parameter is not set, a shed-related tool panel             configuration file will be selected automatically.          
pub async fn api_tool_shed_repositories_new_install_repository_revision_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesNewInstallRepositoryRevisionPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/new/install_repository_revision", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesNewInstallRepositoryRevisionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tool_shed_repositories/install_repository_revision         Install a specified repository revision from a specified tool shed into Galaxy.          :param key: the current Galaxy admin user's API key          The following parameters are included in the payload.         :param tool_shed_url (required): the base URL of the Tool Shed from which to install the Repository         :param name (required): the name of the Repository         :param owner (required): the owner of the Repository         :param changeset_revision (required): the changeset_revision of the RepositoryMetadata object associated with the Repository         :param new_tool_panel_section_label (optional):              label of a new section to be added to the Galaxy tool panel in which to load             tools contained in the Repository.  Either this parameter must be an empty string or             the tool_panel_section_id parameter must be an empty string or both must be an empty             string (both cannot be used simultaneously).          :param tool_panel_section_id (optional):              id of the Galaxy tool panel section in which to load tools contained in the Repository.             If this parameter is an empty string and the above new_tool_panel_section_label parameter is an             empty string, tools will be loaded outside of any sections in the tool panel.  Either this             parameter must be an empty string or the tool_panel_section_id parameter must be an empty string             of both must be an empty string (both cannot be used simultaneously).          :param install_repository_dependencies (optional):              Set to True if you want to install repository dependencies defined for the specified             repository being installed.  The default setting is False.          :param install_tool_dependencies (optional):              Set to True if you want to install tool dependencies defined for the specified repository being             installed.  The default setting is False.          :param shed_tool_conf (optional):              The shed-related tool panel configuration file configured in the \"tool_config_file\" setting in the Galaxy config file             (e.g., galaxy.ini).  At least one shed-related tool panel config file is required to be configured. Setting             this parameter to a specific file enables you to choose where the specified repository will be installed because             the tool_path attribute of the <toolbox> from the specified file is used as the installation location             (e.g., <toolbox tool_path=\"database/shed_tools\">).  If this parameter is not set, a shed-related tool panel             configuration file will be selected automatically.          
pub async fn api_tool_shed_repositories_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/tool_shed_repositories/reset_metadata_on_installed_repositories          Resets all metadata on all repositories installed into Galaxy in an \"orderly fashion\".          :param key: the API key of the Galaxy admin user.         
pub async fn api_tool_shed_repositories_reset_metadata_on_installed_repositories_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesResetMetadataOnInstalledRepositoriesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/reset_metadata_on_installed_repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesResetMetadataOnInstalledRepositoriesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_tool_shed_repositories_reset_metadata_on_selected_installed_repositories_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRepositoriesResetMetadataOnSelectedInstalledRepositoriesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed_repositories/reset_metadata_on_selected_installed_repositories", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRepositoriesResetMetadataOnSelectedInstalledRepositoriesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tool_shed/request         
pub async fn api_tool_shed_request_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolShedRequestGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tool_shed/request", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolShedRequestGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tools          returns a list of tools defined by parameters          :param in_panel: if true, tools are returned in panel structure,                          including sections and labels         :param view: ToolBox view to apply (default is 'default')         :param trackster: if true, only tools that are compatible with                           Trackster are returned         :param q: if present search on the given query will be performed         :param tool_id: if present the given tool_id will be searched for                         all installed versions         
pub async fn api_tools_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tools/{tool_id}/build_dependency_cache         Attempts to cache installed dependencies.          parameters:             force_rebuild:           If true and chache dir exists, attempts to delete cache dir         
pub async fn api_tools_id_build_dependency_cache_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsIdBuildDependencyCachePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{id}/build_dependency_cache", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsIdBuildDependencyCachePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/tools/{tool_id}/dependencies          Attempts to uninstall requirements via the dependency resolver          parameters:              index:                  index of dependency resolver to use when installing dependency.                 Defaults to using the highest ranking resolver              resolver_type: Use the dependency resolver of this resolver_type to install dependency         
pub async fn api_tools_id_dependencies_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsIdDependenciesDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{id}/dependencies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsIdDependenciesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tools/{tool_id}/dependencies          This endpoint is also available through POST /api/tools/{tool_id}/install_dependencies,         but will be deprecated in the future.          Attempts to install requirements via the dependency resolver          parameters:             index:                 index of dependency resolver to use when installing dependency.                 Defaults to using the highest ranking resolver              resolver_type:           Use the dependency resolver of this resolver_type to install dependency.             build_dependency_cache:  If true, attempts to cache dependencies for this tool             force_rebuild:           If true and cache dir exists, attempts to delete cache dir         
pub async fn api_tools_id_dependencies_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsIdDependenciesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{id}/dependencies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsIdDependenciesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/tools/{tool_id}          Returns tool information              parameters:                  io_details   - if true, parameters and inputs are returned                 link_details - if true, hyperlink to the tool is returned                 tool_version - if provided return this tool version         
pub async fn api_tools_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tools/{tool_id}/dependencies          This endpoint is also available through POST /api/tools/{tool_id}/install_dependencies,         but will be deprecated in the future.          Attempts to install requirements via the dependency resolver          parameters:             index:                 index of dependency resolver to use when installing dependency.                 Defaults to using the highest ranking resolver              resolver_type:           Use the dependency resolver of this resolver_type to install dependency.             build_dependency_cache:  If true, attempts to cache dependencies for this tool             force_rebuild:           If true and cache dir exists, attempts to delete cache dir         
pub async fn api_tools_id_install_dependencies_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsIdInstallDependenciesPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{id}/install_dependencies", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsIdInstallDependenciesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/tools         Execute tool with a given parameter payload          :param input_format: input format for the payload. Possible values are           the default 'legacy' (where inputs nested inside conditionals or           repeats are identified with e.g. '<conditional_name>|<input_name>') or           '21.01' (where inputs inside conditionals or repeats are nested           elements).         :type input_format: str         
pub async fn api_tools_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_tools_tool_id_convert_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiToolsToolIdConvertPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/tools/{tool_id}/convert", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiToolsToolIdConvertPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_trs_consume_servers_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiTrsConsumeServersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/trs_consume/servers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiTrsConsumeServersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_trs_consume_trs_server_tools_tool_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiTrsConsumeTrsServerToolsToolIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/trs_consume/{trs_server}/tools/{tool_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiTrsConsumeTrsServerToolsToolIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_trs_consume_trs_server_tools_tool_id_versions_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiTrsConsumeTrsServerToolsToolIdVersionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/trs_consume/{trs_server}/tools/{tool_id}/versions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiTrsConsumeTrsServerToolsToolIdVersionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_trs_consume_trs_server_tools_tool_id_versions_version_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiTrsConsumeTrsServerToolsToolIdVersionsVersionIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/trs_consume/{trs_server}/tools/{tool_id}/versions/{version_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiTrsConsumeTrsServerToolsToolIdVersionsVersionIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/trs_search          Search a TRS server.          :param query: search query         :type  query: str         
pub async fn api_trs_search_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiTrsSearchGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/trs_search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiTrsSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Exposed as POST /api/upload/hooks and /api/upload/resumable_upload         
pub async fn api_upload_hooks_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUploadHooksPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/upload/hooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUploadHooksPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Exposed as POST /api/upload/hooks and /api/upload/resumable_upload         
pub async fn api_upload_resumable_upload_session_id_patch(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUploadResumableUploadSessionIdPatchError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/upload/resumable_upload/{session_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUploadResumableUploadSessionIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_uploads_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUploadsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/uploads", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUploadsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/uploads/         
pub async fn api_uploads_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUploadsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/uploads", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUploadsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users         GET /api/users/deleted         Displays a collection (list) of users.          :param deleted: (optional) If true, show deleted users         :type  deleted: bool          :param f_email: (optional) An email address to filter on. (Non-admin                         users can only use this if ``expose_user_email`` is ``True`` in                         galaxy.ini)         :type  f_email: str          :param f_name: (optional) A username to filter on. (Non-admin users                        can only use this if ``expose_user_name`` is ``True`` in                        galaxy.ini)         :type  f_name: str          :param f_any: (optional) Filter on username OR email. (Non-admin users                        can use this, the email filter and username filter will                        only be active if their corresponding ``expose_user_*`` is                        ``True`` in galaxy.ini)         :type  f_any: str         
pub async fn api_users_deleted_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersDeletedGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/deleted", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersDeletedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users/{encoded_id}         GET /api/users/deleted/{encoded_id}         GET /api/users/current         Displays information about a user.         
pub async fn api_users_deleted_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersDeletedIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/deleted/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersDeletedIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/users/deleted/{id}/undelete         Undelete the user with the given ``id``          :param id: the encoded id of the user to be undeleted         :type  id: str         
pub async fn api_users_deleted_id_undelete_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersDeletedIdUndeletePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/deleted/{id}/undelete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersDeletedIdUndeletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users         GET /api/users/deleted         Displays a collection (list) of users.          :param deleted: (optional) If true, show deleted users         :type  deleted: bool          :param f_email: (optional) An email address to filter on. (Non-admin                         users can only use this if ``expose_user_email`` is ``True`` in                         galaxy.ini)         :type  f_email: str          :param f_name: (optional) A username to filter on. (Non-admin users                        can only use this if ``expose_user_name`` is ``True`` in                        galaxy.ini)         :type  f_name: str          :param f_any: (optional) Filter on username OR email. (Non-admin users                        can use this, the email filter and username filter will                        only be active if their corresponding ``expose_user_*`` is                        ``True`` in galaxy.ini)         :type  f_any: str         
pub async fn api_users_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Unified 'get or create' for API key         
pub async fn api_users_id_api_key_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdApiKeyGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/api_key", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdApiKeyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Get API key inputs.         
pub async fn api_users_id_api_key_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdApiKeyInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/api_key/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdApiKeyInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Get API key inputs with new API key.         
pub async fn api_users_id_api_key_inputs_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdApiKeyInputsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/api_key/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdApiKeyInputsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Create API key.         
pub async fn api_users_id_api_key_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdApiKeyPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/api_key", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdApiKeyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users/{id}/custom_builds         Returns collection of custom builds.          :param id: the encoded id of the user         :type  id: str         
pub async fn api_users_id_custom_builds_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdCustomBuildsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/custom_builds", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdCustomBuildsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/users/{id}/custom_builds/{key}         Delete a custom build.          :param id: the encoded id of the user         :type  id: str          :param id: custom build key to be deleted         :type  id: str         
pub async fn api_users_id_custom_builds_key_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdCustomBuildsKeyDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/custom_builds/{key}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdCustomBuildsKeyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/users/{id}/custom_builds/{key}         Add new custom build.          :param id: the encoded id of the user         :type  id: str          :param id: custom build key         :type  id: str          :param payload: data with new build details         :type  payload: dict         
pub async fn api_users_id_custom_builds_key_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdCustomBuildsKeyPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/custom_builds/{key}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdCustomBuildsKeyPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/users/{id}         delete the user with the given ``id``         Functionality restricted based on admin status          :param id: the encoded id of the user to delete         :type  id: str          :param purge: (optional) if True, purge the user         :type  purge: bool         
pub async fn api_users_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. Remove the object from user's favorites         DELETE /api/users/{id}/favorites/{object_type}/{object_id:.*?}          :param id: the encoded id of the user         :type  id: str         :param object_type: the object type that users wants to favorite         :type  object_type: str         :param object_id: the id of an object that users wants to remove from favorites         :type  object_id: str         
pub async fn api_users_id_favorites_object_type_object_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdFavoritesObjectTypeObjectIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/favorites/{object_type}/{object_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdFavoritesObjectTypeObjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. Add the object to user's favorites         PUT /api/users/{id}/favorites/{object_type}          :param id: the encoded id of the user         :type  id: str         :param object_type: the object type that users wants to favorite         :type  object_type: str         :param object_id: the id of an object that users wants to favorite         :type  object_id: str         
pub async fn api_users_id_favorites_object_type_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdFavoritesObjectTypePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/favorites/{object_type}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdFavoritesObjectTypePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users/{encoded_id}         GET /api/users/deleted/{encoded_id}         GET /api/users/current         Displays information about a user.         
pub async fn api_users_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/users/{id}/information/inputs         Return user details such as username, email, addresses etc.          :param id: the encoded id of the user         :type  id: str         
pub async fn api_users_id_information_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdInformationInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/information/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdInformationInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/users/{id}/information/inputs         Save a user's email, username, addresses etc.          :param id: the encoded id of the user         :type  id: str          :param payload: data with new settings         :type  payload: dict         
pub async fn api_users_id_information_inputs_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdInformationInputsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/information/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdInformationInputsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Return available password inputs.         
pub async fn api_users_id_password_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdPasswordInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/password/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdPasswordInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Allows to the logged-in user to change own password.         
pub async fn api_users_id_password_inputs_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdPasswordInputsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/password/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdPasswordInputsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Get the user's default permissions for the new histories         
pub async fn api_users_id_permissions_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdPermissionsInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/permissions/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdPermissionsInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Set the user's default permissions for the new histories         
pub async fn api_users_id_permissions_inputs_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdPermissionsInputsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/permissions/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdPermissionsInputsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          update( self, trans, id, payload, **kwd )         * PUT /api/users/{id}             updates the values for the item with the given ``id``          :type id: str         :param id: the encoded id of the item to update         :type payload: dict         :param payload: a dictionary of new attribute values          :rtype: dict         :returns: an error object if an error occurred or a dictionary containing             the serialized item after any changes         
pub async fn api_users_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          API call for fetching toolbox filters data. Toolbox filters are specified in galaxy.ini.         The user can activate them and the choice is stored in user_preferences.         
pub async fn api_users_id_toolbox_filters_inputs_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdToolboxFiltersInputsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/toolbox_filters/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdToolboxFiltersInputsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          API call to update toolbox filters data.         
pub async fn api_users_id_toolbox_filters_inputs_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersIdToolboxFiltersInputsPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users/{id}/toolbox_filters/inputs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersIdToolboxFiltersInputsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/users         Creates a new Galaxy user.         
pub async fn api_users_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiUsersPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiUsersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/visualizations:         
pub async fn api_visualizations_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiVisualizationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/visualizations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiVisualizationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/visualizations/{viz_id}         
pub async fn api_visualizations_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiVisualizationsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/visualizations/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiVisualizationsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/visualizations/{encoded_visualization_id}         
pub async fn api_visualizations_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiVisualizationsIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/visualizations/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiVisualizationsIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/visualizations         creates a new visualization using the given payload          POST /api/visualizations?import_id={encoded_visualization_id}         imports a copy of an existing visualization into the user's workspace         
pub async fn api_visualizations_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiVisualizationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/visualizations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiVisualizationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/webhooks/          Return all webhooks.         
pub async fn api_webhooks_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWebhooksGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/webhooks", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWebhooksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/webhooks/{webhook_id}/data/{params}          Return the result of executing helper function.         
pub async fn api_webhooks_webhook_id_data_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWebhooksWebhookIdDataGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/webhooks/{webhook_id}/data", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWebhooksWebhookIdDataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{encoded_workflow_id}/download          Returns a selected workflow.          :type   style:  str         :param  style:  Style of export. The default is 'export', which is the meant to be used                         with workflow import endpoints. Other formats such as 'instance', 'editor',                         'run' are more tied to the GUI and should not be considered stable APIs.                         The default format for 'export' is specified by the                         admin with the `default_workflow_export_format` config                         option. Style can be specified as either 'ga' or 'format2' directly                         to be explicit about which format to download.          :param  instance:                 true if fetch by Workflow ID instead of StoredWorkflow id, false                                           by default.         :type   instance:                 boolean         
pub async fn api_workflows_download_workflow_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsDownloadWorkflowIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/download/{workflow_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsDownloadWorkflowIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/workflows/get_tool_predictions          Fetch predicted tools for a workflow          :type   payload: dict         :param  payload:              a dictionary containing two parameters             'tool_sequence' - comma separated sequence of tool ids             'remote_model_url' - (optional) path to the deep learning model         
pub async fn api_workflows_get_tool_predictions_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsGetToolPredictionsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/get_tool_predictions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsGetToolPredictionsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/workflows/{encoded_workflow_id}         Deletes a specified workflow         Author: rpark          copied from galaxy.web.controllers.workflows.py (delete)         
pub async fn api_workflows_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{encoded_workflow_id}          :param  instance:                 true if fetch by Workflow ID instead of StoredWorkflow id, false                                           by default.         :type   instance:                 boolean          Displays information needed to run a workflow.         
pub async fn api_workflows_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/workflows/{id}          Update the workflow stored with ``id``.          :type   id:      str         :param  id:      the encoded id of the workflow to update         :param  instance: true if fetch by Workflow ID instead of StoredWorkflow id, false by default.         :type   instance: boolean         :type   payload: dict         :param  payload: a dictionary containing any or all the              :workflow:                  the json description of the workflow as would be                 produced by GET workflows/<id>/download or                 given to `POST workflows`                  The workflow contents will be updated to target this.              :name:                  optional string name for the workflow, if not present in payload,                 name defaults to existing name              :annotation:                  optional string annotation for the workflow, if not present in payload,                 annotation defaults to existing annotation              :menu_entry:                  optional boolean marking if the workflow should appear in the user's menu,                 if not present, workflow menu entries are not modified              :tags:                  optional list containing list of tags to add to the workflow (overwriting                 existing tags), if not present, tags are not modified              :from_tool_form:                  True iff encoded state coming in is encoded for the tool form.           :rtype:     dict         :returns:   serialized version of the workflow         
pub async fn api_workflows_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          * PUT /api/workflows/{id}/refactor             updates the workflow stored with ``id``          :type   id:      str         :param  id:      the encoded id of the workflow to update         :param  instance:                 true if fetch by Workflow ID instead of StoredWorkflow id, false                                           by default.         :type   instance:                 boolean         :type   payload: dict         :param  payload: a dictionary containing list of actions to apply.         :rtype:     dict         :returns:   serialized version of the workflow         
pub async fn api_workflows_id_refactor_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsIdRefactorPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{id}/refactor", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsIdRefactorPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/workflows/import         Import a workflow shared by other users.          :param  workflow_id:      the workflow id (required)         :type   workflow_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_import_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsImportPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Get workflows present in the tools panel         GET /api/workflows/menu         
pub async fn api_workflows_menu_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsMenuGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/menu", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsMenuGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          Save workflow menu to be shown in the tool panel         PUT /api/workflows/menu         
pub async fn api_workflows_menu_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsMenuPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/menu", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsMenuPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/workflows/upload         Importing dynamic workflows from the api. Return newly generated workflow id.         Author: rpark          # currently assumes payload['workflow'] is a json representation of a workflow to be inserted into the database          Deprecated in favor to POST /api/workflows with encoded 'workflow' in         payload the same way.         
pub async fn api_workflows_upload_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsUploadPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/upload", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsUploadPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_workflows_workflow_id_annotation_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdAnnotationGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdAnnotationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_workflows_workflow_id_annotation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdAnnotationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/annotation/{id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdAnnotationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete. None
pub async fn api_workflows_workflow_id_annotation_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdAnnotationPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/annotation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdAnnotationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{encoded_workflow_id}/download          Returns a selected workflow.          :type   style:  str         :param  style:  Style of export. The default is 'export', which is the meant to be used                         with workflow import endpoints. Other formats such as 'instance', 'editor',                         'run' are more tied to the GUI and should not be considered stable APIs.                         The default format for 'export' is specified by the                         admin with the `default_workflow_export_format` config                         option. Style can be specified as either 'ga' or 'format2' directly                         to be explicit about which format to download.          :param  instance:                 true if fetch by Workflow ID instead of StoredWorkflow id, false                                           by default.         :type   instance:                 boolean         
pub async fn api_workflows_workflow_id_download_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdDownloadGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/download", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdDownloadGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations         GET /api/invocations          Get the list of a user's workflow invocations. If workflow_id is supplied         (either via URL or query parameter) it should be an encoded StoredWorkflow id         and returned invocations will be restricted to that workflow. history_id (an encoded         History id) can be used to further restrict the query. If neither a workflow_id or         history_id is supplied, all the current user's workflow invocations will be indexed         (as determined by the invocation being executed on one of the user's histories).          :param  workflow_id:      an encoded stored workflow id to restrict query to         :type   workflow_id:      str          :param  instance:         true if fetch by Workflow ID instead of StoredWorkflow id, false                                   by default.         :type   instance:         boolean          :param  history_id:       an encoded history id to restrict query to         :type   history_id:       str          :param  job_id:           an encoded job id to restrict query to         :type   job_id:           str          :param  user_id:          an encoded user id to restrict query to, must be own id if not admin user         :type   user_id:          str          :param  view:             level of detail to return per invocation 'element' or 'collection'.         :type   view:             str          :param  step_details:     If 'view' is 'element', also include details on individual steps.         :type   step_details:     bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_invocations_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute/download          Returns a selected BioCompute Object as a file for download (HTTP         headers configured with filename and such).          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_workflows_workflow_id_invocations_invocation_id_biocompute_download_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeDownloadGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/biocompute/download", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeDownloadGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute          Return a BioCompute Object for the workflow invocation.          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_workflows_workflow_id_invocations_invocation_id_biocompute_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/biocompute", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdBiocomputeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/workflows/{workflow_id}/invocations/{invocation_id}         DELETE /api/invocations/{invocation_id}         Cancel the specified workflow invocation.          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_invocations_invocation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}         GET /api/invocations/{invocation_id}          Get detailed description of workflow invocation          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_details:       fetch details about individual invocation steps                                     and populate a steps attribute in the resulting                                     dictionary. Defaults to false.         :type   step_details:       bool          :param  legacy_job_state:   If step_details is true, and this is set to true                                     populate the invocation step state with the job state                                     instead of the invocation step state. This will also                                     produce one step per job in mapping jobs to mimic the                                     older behavior with respect to collections. Partially                                     scheduled steps may provide incomplete information                                     and the listed steps outputs are the mapped over                                     step outputs but the individual job outputs                                     when this is set - at least for now.         :type   legacy_job_state:   bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_invocations_invocation_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/jobs_summary         GET /api/invocations/{invocation_id}/jobs_summary          return job state summary info aggregated across all current jobs of workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict         :returns:   a job summary object merged for all steps in workflow invocation         
pub async fn api_workflows_workflow_id_invocations_invocation_id_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report         GET /api/invocations/{invocation_id}/report          Get JSON summarizing invocation for reporting.         
pub async fn api_workflows_workflow_id_invocations_invocation_id_report_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdReportGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/report", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdReportGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report.pdf         GET /api/invocations/{invocation_id}/report.pdf          Get JSON summarizing invocation for reporting.         
pub async fn api_workflows_workflow_id_invocations_invocation_id_report_pdf_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdReportPdfGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/report.pdf", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdReportPdfGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/step_jobs_summary         GET /api/invocations/{invocation_id}/step_jobs_summary          return job state summary info aggregated across per step of the workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict[]         :returns:   an array of job summary object dictionaries for each step         
pub async fn api_workflows_workflow_id_invocations_invocation_id_step_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/step_jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         GET /api/invocations/{invocation_id}/steps/{step_id}          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :param  payload:       payload containing update action information                                for running workflow.          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_invocations_invocation_id_steps_step_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         PUT /api/invocations/{invocation_id}/steps/{step_id}          Update state of running workflow step invocation - still very nebulous         but this would be for stuff like confirming paused steps can proceed         etc....          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_invocations_invocation_id_steps_step_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsInvocationIdStepsStepIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/workflows/{encoded_workflow_id}/invocations          Schedule the workflow specified by `workflow_id` to run.          .. note:: This method takes the same arguments as             :func:`galaxy.webapps.galaxy.api.workflows.WorkflowsAPIController.create` above.          :raises: exceptions.MessageException, exceptions.RequestParameterInvalidException         
pub async fn api_workflows_workflow_id_invocations_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdInvocationsPostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/invocations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdInvocationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_workflows_workflow_id_tags_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdTagsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_workflows_workflow_id_tags_tag_name_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdTagsTagNameDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdTagsTagNameDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_workflows_workflow_id_tags_tag_name_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdTagsTagNameGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdTagsTagNameGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_workflows_workflow_id_tags_tag_name_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdTagsTagNamePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdTagsTagNamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.  
pub async fn api_workflows_workflow_id_tags_tag_name_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdTagsTagNamePutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/tags/{tag_name}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdTagsTagNamePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations         GET /api/invocations          Get the list of a user's workflow invocations. If workflow_id is supplied         (either via URL or query parameter) it should be an encoded StoredWorkflow id         and returned invocations will be restricted to that workflow. history_id (an encoded         History id) can be used to further restrict the query. If neither a workflow_id or         history_id is supplied, all the current user's workflow invocations will be indexed         (as determined by the invocation being executed on one of the user's histories).          :param  workflow_id:      an encoded stored workflow id to restrict query to         :type   workflow_id:      str          :param  instance:         true if fetch by Workflow ID instead of StoredWorkflow id, false                                   by default.         :type   instance:         boolean          :param  history_id:       an encoded history id to restrict query to         :type   history_id:       str          :param  job_id:           an encoded job id to restrict query to         :type   job_id:           str          :param  user_id:          an encoded user id to restrict query to, must be own id if not admin user         :type   user_id:          str          :param  view:             level of detail to return per invocation 'element' or 'collection'.         :type   view:             str          :param  step_details:     If 'view' is 'element', also include details on individual steps.         :type   step_details:     bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_usage_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute/download          Returns a selected BioCompute Object as a file for download (HTTP         headers configured with filename and such).          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_workflows_workflow_id_usage_invocation_id_biocompute_download_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeDownloadGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/biocompute/download", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeDownloadGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/invocations/{invocations_id}/biocompute          Return a BioCompute Object for the workflow invocation.          The BioCompute Object endpoints are in beta - important details such         as how inputs and outputs are represented, how the workflow is encoded,         and how author and version information is encoded, and how URLs are         generated will very likely change in important ways over time.         
pub async fn api_workflows_workflow_id_usage_invocation_id_biocompute_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/biocompute", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdBiocomputeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          DELETE /api/workflows/{workflow_id}/invocations/{invocation_id}         DELETE /api/invocations/{invocation_id}         Cancel the specified workflow invocation.          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_usage_invocation_id_delete(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdDeleteError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}         GET /api/invocations/{invocation_id}          Get detailed description of workflow invocation          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_details:       fetch details about individual invocation steps                                     and populate a steps attribute in the resulting                                     dictionary. Defaults to false.         :type   step_details:       bool          :param  legacy_job_state:   If step_details is true, and this is set to true                                     populate the invocation step state with the job state                                     instead of the invocation step state. This will also                                     produce one step per job in mapping jobs to mimic the                                     older behavior with respect to collections. Partially                                     scheduled steps may provide incomplete information                                     and the listed steps outputs are the mapped over                                     step outputs but the individual job outputs                                     when this is set - at least for now.         :type   legacy_job_state:   bool          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_usage_invocation_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/jobs_summary         GET /api/invocations/{invocation_id}/jobs_summary          return job state summary info aggregated across all current jobs of workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict         :returns:   a job summary object merged for all steps in workflow invocation         
pub async fn api_workflows_workflow_id_usage_invocation_id_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report         GET /api/invocations/{invocation_id}/report          Get JSON summarizing invocation for reporting.         
pub async fn api_workflows_workflow_id_usage_invocation_id_report_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdReportGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/report", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdReportGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/report.pdf         GET /api/invocations/{invocation_id}/report.pdf          Get JSON summarizing invocation for reporting.         
pub async fn api_workflows_workflow_id_usage_invocation_id_report_pdf_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdReportPdfGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/report.pdf", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdReportPdfGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/step_jobs_summary         GET /api/invocations/{invocation_id}/step_jobs_summary          return job state summary info aggregated across per step of the workflow invocation          Warning: We allow anyone to fetch job state information about any object they         can guess an encoded ID for - it isn't considered protected data. This keeps         polling IDs as part of state calculation for large histories and collections as         efficient as possible.          :param  invocation_id:    the invocation id (required)         :type   invocation_id:    str          :rtype:     dict[]         :returns:   an array of job summary object dictionaries for each step         
pub async fn api_workflows_workflow_id_usage_invocation_id_step_jobs_summary_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdStepJobsSummaryGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/step_jobs_summary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdStepJobsSummaryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         GET /api/invocations/{invocation_id}/steps/{step_id}          :param  invocation_id:      the invocation id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :param  payload:       payload containing update action information                                for running workflow.          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_usage_invocation_id_steps_step_id_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          PUT /api/workflows/{workflow_id}/invocations/{invocation_id}/steps/{step_id}         PUT /api/invocations/{invocation_id}/steps/{step_id}          Update state of running workflow step invocation - still very nebulous         but this would be for stuff like confirming paused steps can proceed         etc....          :param  invocation_id:      the usage id (required)         :type   invocation_id:      str          :param  step_id:      encoded id of the WorkflowInvocationStep (required)         :type   step_id:      str          :raises: exceptions.MessageException, exceptions.ObjectNotFound         
pub async fn api_workflows_workflow_id_usage_invocation_id_steps_step_id_put(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdPutError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage/{invocation_id}/steps/{step_id}", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsageInvocationIdStepsStepIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          POST /api/workflows/{encoded_workflow_id}/invocations          Schedule the workflow specified by `workflow_id` to run.          .. note:: This method takes the same arguments as             :func:`galaxy.webapps.galaxy.api.workflows.WorkflowsAPIController.create` above.          :raises: exceptions.MessageException, exceptions.RequestParameterInvalidException         
pub async fn api_workflows_workflow_id_usage_post(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdUsagePostError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/usage", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdUsagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This route has not yet been ported to FastAPI. The documentation may not be complete.          GET /api/workflows/{encoded_workflow_id}/versions          :param  instance:                 true if fetch by Workflow ID instead of StoredWorkflow id, false                                           by default.         :type   instance:                 boolean          Lists all versions of this workflow.         
pub async fn api_workflows_workflow_id_versions_get(configuration: &configuration::Configuration, ) -> Result<(), Error<ApiWorkflowsWorkflowIdVersionsGetError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/workflows/{workflow_id}/versions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<ApiWorkflowsWorkflowIdVersionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

